\documentclass[11pt,a4paper]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} 
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage[final]{pdfpages}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{pdfpages}
\usepackage{listings}

\begin{document}

\begin{flushleft}
Diana Heddadji\\
L2 Informatique\\
16712076\\

\end{flushleft}

\vspace{8\baselineskip}

\begin{center}
{\Huge Système d'exploitation}\\
{\Huge Projet Minishell\\}
\end{center}

\vspace{19\baselineskip}


\begin{flushleft}
Licence : INFORMATIQUE\\
UFR: MITSIC (Mathématiques, informatique, technologies, sciences de l'information et de la communication)\\
Année: 2018/2019 \\
\end{flushleft}


\newpage


\section{Organisation du Projet\\}
\subsection{Les fichiers\\}
\begin{itemize}[label=$\square$]
\item minishel.h\\
\item main.c\\
\item decouper.c\\
\item moncd.c\\
\item commandes.c\\
\item Makefile\\
\item mon-if.c (+ pas inclut dans le projet)\\
\end{itemize}

\newpage
%\lstinputlisting[language=C++]{main.cpp}
\section{Description détaillée des fichiers\\}
\subsection{minishel.h\\}

Il s'agit du fichier header du projet, c'est dans celui-ci que nous inclurons toutes les bibliothèques indispensables au projet.\\ \newline

\underline{Exemple :}\\ \newline

En incluant cette bibliothèque;\newline

\textbf{\#include <sys/wait.h>}\newline

On pourra par la suite, utiliser l'appel système \textbf{wait()} afin d'attendre le changement d'état du fils d'un processus.\newline

On déclare également la constante PROMPT qu'on affichera au cours de l'exécution du programme;\newline

\textbf{\#define PROMPT "\%s@\%s\$"}\newline

Enfin, on énumérera les différentes variables nécessaires au projet ainsi que les prototypes des fonctions utilisées.


\newpage
\subsection{main.c\\}
C'est le fichier principale du projet dans lequel on appellera les fonctions dans un ordre précis.\newline \\

Tout d'abord, on inclut le fichier hearder vu plus haut, puis, on commence par copier le chemin d'accès absolu du répertoire de travail courant dans la chaîne pointée par \textbf{dirsbis}.\newline

\textbf{getcwd(dirsbis, sizeof(dirsbis));}\newline

On appelle ensuite, la fonction \textbf{decouper} qui va se charger de scinder le \textbf{PATH} en plusieurs répertoires.\newline
 
Dans le \textbf{for}, on va lire et traiter chaque ligne de commandes en affichant à chaque fois le chemin du répertoire courant avec \textbf{dirsbis} et en récupérant la valeur de \textbf{USER} avec \textbf{getenv} le tout formaté  par la constante \textbf{PROMPT}.\newline

\textbf{for(printf(PROMPT, getenv("USER"), dirsbis); fgets(ligne, sizeof ligne, stdin) != 0; printf(PROMPT, getenv("USER"), dirsbis))}\newline

Puis, on rappelle une nouvelle fois la fonction \textbf{decouper}, mais cette fois-ci pour scinder une ligne selon la présence d'un point-virgule afin de traiter plusieurs commandes à la fois. On placera "les mots" trouvés dans \textbf{commandes} (c'est-à-dire ceux juste avant chaque ";", il peut en avoir un ou plusieurs car on il peut y avoir des espaces...).\newline

\textbf{decouper(ligne, ";", commandes, MaxMot);}\newline

Ensuite, on déclare un deuxième \textbf{for}, imbriqué dans le premier, pour parcourir à présent les mots contenus dans \textbf{commandes} qu'on a remplit précédemment. Encore une fois, on appelle \textbf{decouper} afin de scinder les mots selon la présence d'un espace, d'une tabulatation ou d'un saut de ligne.\newline

\textbf{decouper(commandes[c], " \t\n", mot, MaxMot);}\newline

A présent, on a bien uniquement un seul mots par case dans le tableau de chaîne de caractères \textbf{commandes}, on va donc pouvoir exécuter ses mots, qui sont enfaîte des commandes.\newline

Afin que la commande qui nous permet de changer de répertoire courant \textbf{(cd ou change directory)} soit reconnue, on l'a crée de façon \textbf{interne} :\newline

\textbf{char * cd = "cd";}\newline

\textbf{if(!strcmp(mot[0],cd))\{\\
	moncd(mot, dir, t);\\
	getcwd(dirsbis, sizeof(dirsbis));\\
	continue;\\
\}}\newline

On déclare une chaîne de caractère initialisée à \textbf{"cd"},
qu'on compare ensuite avec le premier mot qu'on entre sur notre \textbf{shell}. \textbf{strcmp}, déclarée dans \textbf{#include <string.h>}, va se charger d'établir cette comparaison. Si ces deux chaînes sont équivalentes, on appelle la fonction \textbf{moncd} et on récupère le chemin du répertoire courant  avec \textbf{getcwd} après avoir changer de répertoire.\newline

De même, pour sortir proprement du \textbf{shell}, on déclare une chaîne de caractère initialisée à \textbf{"exit"} et si celle-ci est égale à \textbf{mot[0]}, on affiche \textbf{"Bye"}  et on retourne \textbf{0}.\newline

A la fin du \textbf{main}, on a fait un \textbf{fork} dans lequel l'enfant contient la fonction qui traite le cas d'un processus mis en arrière plan ainsi que la gestion de plusieurs commandes.\newline

\textbf{monexec(pathname, mot, NULL, NULL);}\newline

Si une commande est introuvable, on affiche un message d'erreur avant de faire appel à \textbf{exit}.\newline

\href{../screen/c1.png}{../screen/c1.png} : minishell\\
\href{../screen/c2.png}{../screen/c2.png} : exit

\newpage
\subsection{decouper.c\\}

Dans ce fichier, on trouvera une seule fonction mais qui a un rôle fondamental dans notre \textbf{shell} comme on a pu le constater, il s'agit de la fonction \textbf{decouper} qui scinde une ligne, un mot.. en fonction d'un séparateur qu'on indique en paramètre.

Voici son prototype qui est également définie dans le header \textbf{minishel.h} : \newline
\textbf{void decouper(char * ligne, char * separ, char * mot[], int maxmot);}\newline

Dans le tableau de chaîne \textbf{mot}, on y placera les mots trouvés dans \textbf{ligne}, qui a été scindé en fonction de \textbf{separ}, \textbf{maxmot} est la taille de \textbf{mot}.\newline

Afin de construire ces mots, la fonction \textbf{decouper} utilise \textbf{strtok}, définie dans la bibliothèque \textbf{#include <string.h>}, qui permet justement de scinder une chaîne en une séquence d'éléments lexicaux.

\newpage
\subsection{moncd.c\\}

Dans ce fichier, on retrouvera la fonction \textbf{moncd} qui va se charger de changer le répertoire courant en fonction du chemin qu'indiquera l'utilisateur, son prototype est le suivant :\newline

\textbf{void moncd(char ** mot, char * dir, int t);}\newline

Par défaut, si \textbf{cd} ne prend aucun paramètre, on se redirige vers le répertoire \textbf{home}, si cela n'est pas possible, alors on tente de se placer dans le dossier \textbf{tmp}.\newline \\ Sinon, on se place dans le dossier que l'on a indiqué en paramètre.\newline \\ Ensuite, on fait un \textbf{chdir} dans le répertoire donné en argument ou dans celui indiqué par \textbf{HOME} afin de changer de répertoire. A la fin, on teste la valeur de la variable \textbf{t} pour savoir si une erreur s'est produite.\newline \\
\href{../screen/c3.png}{../screen/c3png} : cd

\newpage
\subsection{commandes.c\\}

Dans ce fichier, nous allons retrouver la fonction \textbf{monexec} qui va nous permettre de faire deux choses, à la fois tester si on souhaite mettre une commande en arrière plan, en comparant les mot présents dans le tableau de chaînes, \textbf{char * mot[]}, avec \textbf{"&"}, mais aussi exécuter plusieurs commandes à la fois.\newline

Voici donc son prototype :\newline

\textbf{int monexec(char pathname[], char * mot[]);}\newline

Pour la mise en arrière plan et la gestion de plusieurs commandes, on fait un \textbf{fork} dans lequel l'enfant récupère le \textbf{pid} avant d’exécuter les commandes, le parent lui fait un \textbf{wait(0)}, le tout dans un \textbf{for}.\newline \\
\href{../screen/c4.png}{../screen/c4.png} : Gestion de plusieurs commandes\\
\href{../screen/c5.png}{../screen/c5.png} : sleep


\newpage
\section{Améliorations\\}

Ajouter le traitement de \&\&\\
Ajouter le traitement des redirections (> >> \&> 2> 2>>)\\
Ajouter le traitement des symboles (2>\&1 1<\&2)\\
Faire un historique des commandes : avec les touches fléchés\\
Traitement de quelques méta-caractères comme * ou ?\\
Ajouter le traitement des pipes (|) \\
Auto-complétion\newline \\


Sources:\newline

\href{http://manpagesfr.free.fr/}{manpagesfr.free.fr/}\\
\href{http://www.ai.univ-paris8.fr/~alinehuf/l2/cours4/sources/co-main.c}{co-main.c}\\
\href{http://www.ai.univ-paris8.fr/~alinehuf/l2/cours4/sources/cn-decouper.c}{cn-decouper.c}\\
\href{http://www.ai.univ-paris8.fr/~alinehuf/l2/cours4/sources_exo/exo16_moncd.c}{exo16_moncd.c}


\end{document} 