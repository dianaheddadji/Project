#lang racket/base

(require racket/match)

(require "ast.rkt"
				 "lexer.rkt" 
				 "parser.rkt")

(provide compile-function 
				 data-display
				 data-expr
				 estimation 
				 quit 
				 load-data 
				 main 
				 text)

;compile expressions and operations
(define (comp-op-expr p e r) 
 (match p
   ((Poperator oprtr first_val second_val)	
		(match oprtr                                						 
		 ('add (+  (comp-op-expr first_val e r) (comp-op-expr second_val e r)))
		 ('sub (-  (comp-op-expr first_val e r) (comp-op-expr second_val e r)))
     ('mul (*  (comp-op-expr first_val e r) (comp-op-expr second_val e r)))
     ('div (floor (/  (comp-op-expr first_val e r) 
		  (if (eq? (comp-op-expr second_val e 0) 0) 
			 (begin (eprintf"DivisionbyZero: integer division by 0\n") (exit 1))
       (comp-op-expr second_val e 0)
			)))
		 )
	   ('and (and (comp-op-expr first_val e r)    (comp-op-expr second_val e r)))
	   ('eq  (=  (comp-op-expr first_val e r)     (comp-op-expr second_val e r)))
	   ('ieq (<= (comp-op-expr first_val e r)     (comp-op-expr second_val e r)))
	   ('inf (<  (comp-op-expr first_val e r)     (comp-op-expr second_val e r)))
	   ('mod (modulo (comp-op-expr first_val e r) (comp-op-expr second_val e r)))
	   ('neq (=  (comp-op-expr first_val e r)     (comp-op-expr second_val e r)))
	   ('or  (or (comp-op-expr first_val e r)     (comp-op-expr second_val e r)))
	   ('seq (>= (comp-op-expr first_val e r)     (comp-op-expr second_val e r)))
	   ('sup (>  (comp-op-expr first_val e r)     (comp-op-expr second_val e r)))
		)
	 )
	 ((Pdefine id expr)         							(comp-op-expr expr e r))
	 ((Pbool b)                 							(if b 1 0)) 
	 (#f                     									0)
	 (#t                     									1)
	 ((Pid id)             									  id)
	 ((Pcond condition t f)   								(hash-set e (comp-op-expr condition e r) (comp-op-expr t e r) (comp-op-expr f e r)))
	 ((Ploop condition instr)   							(hash-set e (comp-op-expr condition e r) (comp-op-expr instr e r)))
	 ((Pprint expr)          									(hash-set e (comp-op-expr expr e r)))
	 ((Pparam expr)             							'a0)
	 ((Pnot oprtr val)             						('not (comp-op-expr (not (comp-op-expr val e r)) e r)))
	 ((Pval val)               								val)
 )
)

;This function is used to compile functions from the source language to put their instructions before the main
(define (compile-function p e)
 (match p
  ((list expr)
   (for-each print-instr
    (match expr
	   ((Pbool val)            									'())
		 ((Pdefine i val)        									'())
		 ((Pcond condition t f)  									'())
     ((Pfor i first_val second_val e)   			'())
     ((Pfun i param)      								    '())
		 ((Pid id)                								'())
		 ((Ploop condition instr)    							'())
     ((Pmax x y)            									'())
     ((Pmin x y)            									'())
		 ((Pnot oprtr val)           							'())
		 ((Pprint expr)         									'())
     ((Pprint_ expr)     											'())
		 ((Pprint_nb expr)      									'())
		 ((Poperator oprtr first_val second_val)  '())
     ((Preturn ex)             								'())
		 ((Pval val)              								'())
		 ((Pfunction i param instr)
    	(label (comp-op-expr i e 0))
      (compile-expr (list instr) e)
      (list (J 'ra))))))
    ((cons first-expr second-expr)  (compile-function (list first-expr) e) (compile-function second-expr e))
	)
)

(define (data-display)
 (printf"\n.data\n"))

;for the data expressions
(define (data-expr p e)
 (match p 
  ((list expr) 
  (match expr 
  ((Pbool val)            									(data-match-expr p e))
  ((Pcond condition t f)  									(data-match-expr p e))
  ((Pdefine i val)          								(data-match-expr p e))
  ((Pfor i first_val second_val e)    			(data-match-expr (list e) e))
  ((Pfun i param)  											'())
  ((Pfunction i param expr)									(data-match-expr (list expr) e))
  ((Pid id)              										(data-match-expr p e))
  ((Ploop condition instr)  								(data-match-expr p e))
  ((Pmax x y)           										(data-match-expr p e))
  ((Pmin x y)           										(data-match-expr p e))
  ((Pnot oprtr val)          								(data-match-expr p e))
  ((Pprint_ expr)      											(data-match-expr p e))
  ((Pprint expr)        										(data-match-expr p e))
  ((Pprint_nb expr)       									(data-match-expr p e))
  ((Poperator oprtr first_val second_val)   (data-match-expr p e))
  ((Preturn expr)           								(data-match-expr (list expr) e))
  ((Pval val)             									(data-match-expr p e))))
  ((cons first-expr second-expr)   					(data-match-expr (list first-expr) e) (data-expr second-expr e))
 )
)

;display the .data which correspond to the program instructions
(define (data-match-expr p e)
 (append 
  (match p
	 ((list (Pbool val))	  '())
	 ((list (Pcond condition t f))
		(data-match-expr (list condition) e)
		(data-match-expr (list t) e)
		(data-match-expr (list f) e))
	 ((list (Pdefine i val)) (load-data (hash (comp-op-expr i e 0) (comp-op-expr val e 0))))
	 ((list (Pfor i first_val second_val ex)) (data-match-expr (list ex) e))
	 ((list (Pfun i param)) '())
	 ((list (Pfunction i param instr)) 
	  (data-match-expr (list instr) e))
	 ((list (Pid n))
	  (list (load-data (make-hash '((n . "\nNameError: the entered variable is not defined\n"))))))
	 ((list (Ploop condition instr)) 
		(data-match-expr (list condition) e)
	  (data-match-expr (list instr) e))
	 ((list (Pmax x y))         '())
	 ((list (Pmin x y))					'())
	 ((list (Pnot oprtr val))	'())
	 ((list (Poperator oprtr first_val second_val)) '())
	 ((list (Pprint expr)) (print-data (hash (comp-op-expr expr e 0) (comp-op-expr expr e 0))))
	 ((list (Pprint_ expr)) (data-match-expr (list expr) e))
	 ((list (Pprint_nb expr)) (data-match-expr (list expr) e))
	 ((list (Preturn expr)) (data-match-expr (list expr) e))
	 ((list (Pval val))     '())
  )
 )
)

;to know if the program consists of a single or several instruction(s)
(define (estimation p e)
 (match p
  ((list expr)	(compile-expr p e))
  ((cons first-expr second-expr)	(compile-expr (list first-expr) e)	(estimation second-expr e))
 )
)

;for
(define (for-instr first_val second_val)
 (printf "li $t0, ~a\n" first_val)
 (printf "li $t1, ~a\n" second_val)
 (printf "for :\n")
 (printf "beq $t1, $t0, end_for\naddi $t0, $t0, 1\n")
)

(define (label l) (printf "~a :\n" l))

;match labels and locations in stack
(define (label-location l)
 (match l
  ((Mem m r) 		 (format "~a($~a)" m r))
  ((Lbl label)   (format "~a" label))
 )
)

(define (Lbeq) (printf "beq $v0, $0, Else\n"))

(define (Lbloop) (printf "b loop\n"))

(define (Llabel) (printf "b Endif\nElse:\n"))

(define (Lloop)  (printf "loop:\nbeq $v0, $0, end_loop\n"))

;this function is used to load words in .data label
(define (load-data data)
 (hash-for-each data
  (lambda (k v)
   (if (number? v)
    (printf "~a: .word ~s\n" k v)
    (printf "~a: .asciiz ~s\n" k v)
	 )
	)
 )
)

(define (for) (printf "j for\n"))

(define (main) (printf "main:\n"))

;matches the programs that an if or while can contain
(define (match-prog p e)
 (for-each print-instr 
  (append
   (match p
    ((list (Poperator op first_val second_val))
     (match op 
      ('<<  (append (list (Li 't0 (comp-op-expr first_val e 0)))
                    (list (Sll 'v0 't0 (comp-op-expr second_val e 0)))))
      ('>>  (append (list (Li 't0 (comp-op-expr first_val e 0)))
                    (list (Srl 'v0 't0 (comp-op-expr second_val e 0)))))
      ('and (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
                    (list (And 'v0 't0 't1))))
      ('or  (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
                    (list (Or 'v0 't0 't1))))
      ('add (append (list (Li 't0 (comp-op-expr first_val e 0))) 
                    (list (Addi 'v0 't0 (comp-op-expr second_val e 0)))))
      ('sub (append (list (Li 't0 (comp-op-expr first_val e 0)))
			              (list (Sub 'v0 't0 (comp-op-expr second_val e 0)))))
			('mul (append (list (Li 't0 (comp-op-expr first_val e 0)))
									  (list (Li 't1 (comp-op-expr second_val e 0)))
										(list (Mul 't0 't1))
										(list (Mflo 's0))
								    (list (Add 'v0 'zero 's0))))
		  ('div (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(if (eq? (comp-op-expr second_val e 0) 0) 
											  (begin (eprintf"DivisionbyZero: integer division or modulo by zero\n")  (exit 1))
                        (list (Li 't1 (comp-op-expr second_val e 0))))
										(list (Div 't0 't1))
										(list (Mflo 's0))
										(list (Add 'v0 'zero 's0))))
      ('eq  (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
										(list (Beq 't0 't1 'TRUE))
										(list (B 'FALSE))
										(list (Label 'TRUE))
                    (list (Li 'v0 1))
										(list (B 'next))
                    (list (Label 'FALSE))
                    (list (Li 'v0 0))
                    (list (Label 'next))))
			('ieq (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
										(list (Ble 't0 't1 'TRUE))
										(list (B 'FALSE))
										(list (Label 'TRUE))
                    (list (Li 'v0 1))
									  (list (B 'next))
                    (list (Label 'FALSE))
                    (list (Li 'v0 0))
                    (list (Label 'next))))
      ('inf (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
										(list (Blt 't0 't1 'TRUE))
										(list (B 'FALSE))
										(list (Label 'TRUE))
                    (list (Li 'v0 1))
										(list (B 'next))
                    (list (Label 'FALSE))
                    (list (Li 'v0 0))
                    (list (Label 'next))))
      ('mod (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
										(list (Div 't0 't1))
										(list (Mfhi 's0))
										(list (Add 'v0 'zero 's0))))
      ('neq (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
									  (list (Beq 't0 't1 'FALSE))
										(list (B 'TRUE))
										(list (Label 'FALSE))
                    (list (Li 'v0 0))
										(list (B 'next))
                    (list (Label 'TRUE))
                    (list (Li 'v0 1))
                    (list (Label 'next))))
      ('seq (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
										(list (Bge 't0 't1 'TRUE))
										(list (B 'FALSE))
										(list (Label 'TRUE))
                    (list (Li 'v0 1))
										(list (B 'next))
                    (list (Label 'FALSE))
                    (list (Li 'v0 0))
                    (list (Label 'next))))
			('sup (append (list (Li 't0 (comp-op-expr first_val e 0)))
										(list (Li 't1 (comp-op-expr second_val e 0)))
										(list (Bgt 't0 't1 'TRUE))
										(list (B 'FALSE))
										(list (Label 'TRUE))
                    (list (Li 'v0 1))
										(list (B 'next))
                    (list (Label 'FALSE))
                    (list (Li 'v0 0))
                    (list (Label 'next))))))

     ((list (Pbool val)) (append (list (Li 'v0 (comp-op-expr val e 0)))))
     ((list (Pdefine id val)) (append (list (Lw 't0 (Lbl 'val)))))
 		 ((list (Pfunction id args expr))  '())
     ((list (Pprint expr)) (append (list (Li 'v0 4))
                            (list (La 'a0 (Lbl (comp-op-expr expr e 0))))
                            (list (Syscall))
                            (list (Li 'v0 4))
                            (list (La 'a0 (Lbl 'nl)))
								            (list (Syscall))))
		((list (Pprint_ expr)) (append (list (Lw 'a0 (Lbl (comp-op-expr expr e 0))))
		                        (list (Li 'v0 4))
		                        (list (Syscall))))
    ((list (Pprint_nb expr))
     (list (compile-expr (list expr) e))
     (append (list (Li 'v0 4))
             (list (La 'a0 (Lbl 'nl)))
					   (list (Syscall))))
    ((Preturn expr)        (match-prog (list expr) e))
    ((list (Pval val))      (append (list (Li 'v0 val))))
))))

;to load the character string put in the print in the .data
(define (print-data d)
 (hash-for-each d
  (lambda (k v)
   (printf "~a: .asciiz \"~s\"\n" k v))
 )
)

;match mips instructions
(define (print-instr instr)
 (match instr
  ((Add rd rs r)  (printf "add $~a, $~a, $~a\n" rd rs r))
  ((Addi rd rs i) (printf "addi $~a, $~a, ~a\n" rd rs i))
  ((And rd r1 r2) (printf "and $~a, $~a, $~a\n"rd r1 r2))
  ((B lbl)        (printf "b ~a\n" lbl))
  ((Beq r1 r2 lbl)(printf "beq $~a, $~a, ~a\n" r1 r2 lbl))
  ((Bge r1 r2 lbl)(printf "bge $~a, $~a, ~a\n" r1 r2 lbl))
  ((Bgt r1 r2 lbl)(printf "bgt $~a, $~a, ~a\n" r1 r2 lbl))
  ((Ble r1 r2 lbl)(printf "ble $~a, $~a, ~a\n" r1 r2 lbl))
  ((Blt r1 r2 lbl)(printf "blt $~a, $~a, ~a\n" r1 r2 lbl))
  ((Div r1 r2)    (printf "div $~a, $~a\n" r1 r2))
  ((La r a)       (printf "la $~a, ~a\n" r (label-location a)))
  ((Label l)      (printf "~a:\n" l))
  ((Li r i)       (printf "li $~a, ~a\n" r i))
  ((Lw r loc)     (printf "lw $~a, ~a\n" r (label-location loc)))
  ((Mfhi rs)      (printf "mfhi $~a\n" rs))
  ((Mflo rs)      (printf "mflo $~a\n" rs))
  ((Move rd rs)   (printf "move $~a, $~a\n" rd rs))
  ((Mul r1 r2)    (printf "mul $~a, $~a\n" r1 r2))
  ((Sw r loc)     (printf "sw $~a, ~a\n" r (label-location loc)))
  ((Syscall)      (printf "syscall\n"))
  ((J r)          (printf "j $~a\n" r))
  ((Jal r)        (printf "jal ~a\n" r))
  ((Jr r)         (printf "jr $~a\n" r))
  ((Or rd r1 r2)  (printf "or $~a, $~a, $~a\n"rd r1 r2))
  ((Sll d s i)    (printf "sll $~a, $~a, ~a\n" d s i))
  ((Srl d s i)    (printf "srl $~a, $~a, ~a\n" d s i))
  ((Sub rd rs i)  (printf "sub $~a, $~a, ~a\n" rd rs i))
  ((Xor rd r1 r2) (printf "xor $~a, $~a, $~a\n"rd r1 r2))
 )
)

;Assign to each argument of a function, the register $a which corresponds to it
(define (register-argument expr e acc)
 (match expr
  ((list (Pid n))  (hash-set e n acc))
  ((cons n l)      ((hash-set e n acc) (register-argument (list l) e (+ acc 1))))
 )
)

(define (text) (printf ".text\n.globl main\n"))

;translate expressions to mips expressions
(define (compile-expr p e)
 (for-each print-instr 
  (append
   (match p
    ((list (Pbool val))	
		 (append (list (Li 'v0 1))
      (list (La 'a0 (Lbl (comp-op-expr val e 0))))
      (list (Syscall))))
    ((list (Pcond condition t f))  
     (match-prog (list condition) e)
      (Lbeq)
      (match-prog (list t) e)
      (Llabel)
      (match-prog (list f) e)
      (list (Label 'Endif)))
    ((list (Pdefine id val)) (append (list (Lw 't0 (Lbl (comp-op-expr id e 0))))))
    ((list (Pfor id first_val second_val expr))
     (for-instr (comp-op-expr first_val e 0) (comp-op-expr second_val e 0))
     (match-prog (list expr) e)
     (for)
     (list (Label 'end_for)))
    ((list (Pfun id args)) (append (list (Jal (comp-op-expr id e 0)))))
 		((list (Pfunction id args expr))  '())
    ((list (Pid n))	(append (list (Li 'v0 4))
                    (list (La 'a0 (Lbl 'n)))
                    (list (Syscall))))
		((list (Ploop condition instr))
		 (match-prog (list condition) e)
		 (Lloop)
		 (match-prog (list instr) e)
		 (Lbloop)
		 (list (Label 'end_loop)))
    ((list (Pmax a b))
     (append (list (Li 't0 (comp-op-expr a e 0)))
             (list (Li 't1 (comp-op-expr b e 0)))
             (list (Bgt 't0 't1 'maxaval))
             (list (B 'maxbval))
						 (list (Label 'maxaval))
             (list (Li 'v0 1))
             (list (Move 'a0 't0))
             (list (Syscall))
		  	     (list (B 'maxnext))
             (list (Label 'maxbval))
             (list (Li 'v0 1))
             (list (Move 'a0 't1))
             (list (Syscall))
             (list (Label 'maxnext))))
	  ((list (Pmin a b))
	   (append (list (Li 't0 (comp-op-expr a e 0)))
	           (list (Li 't1 (comp-op-expr b e 0)))
	           (list (Bgt 't0 't1 'minaval))
	           (list (B 'minbval))
						 (list (Label 'minaval))
	           (list (Li 'v0 1))
	           (list (Move 'a0 't1))
	           (list (Syscall))
					   (list (B 'minnext))
	           (list (Label 'minbval))
	           (list (Li 'v0 1))
	           (list (Move 'a0 't0))
	           (list (Syscall))
	           (list (Label 'minnext))))
   	((list (Pnot op v)) (append (list (Li 't0 (comp-op-expr v e 0)))
						 (list (Li 't1 1))
             (list (Xor 'a0 't0 't1))
             (list (Li 'v0 1))
						 (list (Syscall)))) 
    ((list (Pparam id))
      (list (Move 't0 'a0)))
    ((list (Poperator op first_val second_val))
      (match op 
        ('add (append (if (number? (comp-op-expr first_val e 0)) (list (Li 't0 (comp-op-expr first_val e 0))) '())
	                    (list (Addi 't0 't0 (comp-op-expr second_val e 0)))
			                (list (Li 'v0 1))
			                (list (Move 'a0 't0))						         
                      (list (Syscall))))
        ('sub (append (list (Li 't0 (comp-op-expr first_val e 0)))
				              (list (Sub 't0 't0 (comp-op-expr second_val e 0)))
			                (list (Li 'v0 1))
			                (list (Move 'a0 't0))
									    (list (Syscall))))
				('mul (append (list (Li 't0 (comp-op-expr first_val e 0)))
										  (list (Li 't1 (comp-op-expr second_val e 0)))
											(list (Mul 't0 't1))
											(list (Mflo 's0))
                      (list (Li 'v0 1))
									    (list (Add 'a0 'zero 's0))
	                    (list (Syscall))))
			  ('div (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(if (eq? (comp-op-expr second_val e 0) 0) 
											 (begin (eprintf"DivisionbyZero: integer division or modulo by zero\n") (exit 1))
                        (list (Li 't1 (comp-op-expr second_val e 0))))
											(list (Div 't0 't1))
											(list (Mflo 's0))
                      (list (Li 'v0 1))
											(list (Add 'a0 'zero 's0))
	                    (list (Syscall))))
        ('and (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
                      (list (And 't2 't0 't1))
                      (list (Li 'v0 1))
                      (list (Move 'a0 't2))
											(list (Syscall))))
        ('eq  (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
											(list (Beq 't0 't1 'eqTRUE))
											(list (B 'eqFALSE))
											(list (Label 'eqTRUE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 't)))
                      (list (Syscall))
											(list (B 'eqnext))
                      (list (Label 'eqFALSE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 'f)))
                      (list (Syscall))
                      (list (Label 'eqnext))))
        ('exp (append (list (Li 'a0 (comp-op-expr (Poperator op first_val second_val) e 0)))
                      (list (Li 'v0 1))
                      (list (Syscall))))
				('ieq (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
											(list (Ble 't0 't1 'ieqTRUE))
											(list (B 'ieqFALSE))
											(list (Label 'ieqTRUE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 't)))
                      (list (Syscall))
										  (list (B 'ieqnext))
                      (list (Label 'ieqFALSE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 'f)))
                      (list (Syscall))
                      (list (Label 'ieqnext))))
        ('inf (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
											(list (Blt 't0 't1 'infTRUE))
											(list (B 'infFALSE))
											(list (Label 'infTRUE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 't)))
                      (list (Syscall))
											(list (B 'infnext))
                      (list (Label 'infFALSE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 'f)))
                      (list (Syscall))
                      (list (Label 'infnext))))
        ('mod (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
											(list (Div 't0 't1))
											(list (Mfhi 's0))
                      (list (Li 'v0 1))
											(list (Add 'a0 'zero 's0))
	                    (list (Syscall))))
        ('neq (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
										  (list (Beq 't0 't1 'neqFALSE))
											(list (B 'neqTRUE))
											(list (Label 'neqFALSE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 'f)))
                      (list (Syscall))
											(list (B 'neqnext))
                      (list (Label 'neqTRUE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 't)))
                      (list (Syscall))
                      (list (Label 'neqnext))))
        ('or  (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
                      (list (Or 't2 't0 't1))
                      (list (Li 'v0 1))
                      (list (Move 'a0 't2))
											(list (Syscall))))
        ('seq (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
											(list (Bge 't0 't1 'seqTRUE))
											(list (B 'seqFALSE))
											(list (Label 'seqTRUE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 't)))
                      (list (Syscall))
											(list (B 'seqnext))
                      (list (Label 'seqFALSE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 'f)))
                      (list (Syscall))
                      (list (Label 'seqnext))))
				('sup (append (list (Li 't0 (comp-op-expr first_val e 0)))
											(list (Li 't1 (comp-op-expr second_val e 0)))
											(list (Bgt 't0 't1 'supTRUE))
											(list (B 'supFALSE))
											(list (Label 'supTRUE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 't)))
                      (list (Syscall))
											(list (B 'supnext))
                      (list (Label 'supFALSE))
                      (list (Li 'v0 4))
                      (list (La 'a0 (Lbl 'f)))
                      (list (Syscall))
                      (list (Label 'supnext))))
        ('<<  (append (list (Li 't0 (comp-op-expr first_val e 0)))
                      (list (Sll 'a0 't0 (comp-op-expr second_val e 0)))
                      (list (Li 'v0 1))
                      (list (Syscall))))  
        ('>>  (append (list (Li 't0 (comp-op-expr first_val e 0)))
                      (list (Srl 'a0 't0 (comp-op-expr second_val e 0)))
                      (list (Li 'v0 1))
                      (list (Syscall))))))
    ((list (Pprint expr))
     (append (list (Li 'v0 4))
             (list (La 'a0 (Lbl (comp-op-expr expr e 0))))
             (list (Syscall))
             (list (Li 'v0 4))
             (list (La 'a0 (Lbl 'nl)))
						(list (Syscall))))
    ((list (Pprint_ expr)) (append (list (Lw 'a0 (Lbl (comp-op-expr expr e 0))))
                            (list (Li 'v0 1))
                            (list (Syscall))))
    ((list (Pprint_nb expr))
     (list (compile-expr (list expr) e))
     (append (list (Li 'v0 4))
             (list (La 'a0 (Lbl 'nl)))
			  		 (list (Syscall))))
    ((list (Preturn expr)) (match-prog (list expr) e)
                           (list (Li 't9 1)))
    ((list (Pval val)) (append  (list (Li 'v0 1))
                     (list (La 'a0 (Lbl val)))
                     (list (Syscall))))                            
))))

(define (quit)
  (printf "li $v0, 4\nla $a0, nl\nsyscall\nli $v0, 10\nsyscall\n"))
